import os, os.path, sys, fnmatch
   
def Glob( includes = Split( '*' ), excludes = None, dir = '.'):
   """Similar to glob.glob, except globs SCons nodes, and thus sees
   generated files and files from build directories.  Basically, it sees
   anything SCons knows about.  A key subtlety is that since this function
   operates on generated nodes as well as source nodes on the filesystem,
   it needs to be called after builders that generate files you want to
   include.

   It will return both Dir entries and File entries
   """
   def fn_filter(node):
      fn = os.path.basename(str(node))
      match = 0
      for include in includes:
         if fnmatch.fnmatchcase( fn, include ):
            match = 1
            break

      if match == 1 and not excludes is None:
         for exclude in excludes:
            if fnmatch.fnmatchcase( fn, exclude ):
               match = 0
               break

      return match

   def filter_nodes(where):
       children = filter(fn_filter, where.all_children())
       nodes = []
       for f in children:
           nodes.append(gen_node(f))
       return nodes

   def gen_node(n):
       """Checks first to see if the node is a file or a dir, then
       creates the appropriate node. [code seems redundant, if the node
       is a node, then shouldn't it just be left as is?
       """
       if type(n) in (type(''), type(u'')):
           path = n
       else:
           path = n.abspath
       if os.path.isdir(path):
           return Dir(n)
       else:
           return File(n)

   here = Dir(dir)
   nodes = filter_nodes(here)

   node_srcs = [n.srcnode() for n in nodes]

   src = here.srcnode()
   if src is not here:
       for s in filter_nodes(src):
           if s not in node_srcs:
               # Probably need to check if this node is a directory
               nodes.append(gen_node(os.path.join(dir,os.path.basename(str(s)))))

   return nodes


#
# Functions
#
def Glob(match):
    """Similar to glob.glob, except globs SCons nodes, and thus sees
    generated files and files from build directories.  Basically, it sees
    anything SCons knows about.  A key subtlety is that since this function
    operates on generated nodes as well as source nodes on the filesystem,
    it needs to be called after builders that generate files you want to
    include."""
    def fn_filter(node):
        fn = str(node)
        return fnmatch.fnmatch(os.path.basename(fn), match)

    here = Dir('.')

    children = here.all_children()
    nodes = map(File, filter(fn_filter, children))
    node_srcs = [n.srcnode() for n in nodes]

    src = here.srcnode()
    if src is not here:
        src_children = map(File, filter(fn_filter, src.all_children()))
        for s in src_children:
            if s not in node_srcs:
                nodes.append(File(os.path.basename(str(s))))

    return nodes


#
# Paths
#
subdirs = ['subdir1', 'subdir2']
modpath = map(lambda d: os.path.join('#/build',d), subdirs)

#
# Environment
#
env = Environment(
    F90PATH = modpath,
    FORTRAN = '/opt/intel_fc_80/bin/ifort',
    #FORTRANMODDIRPREFIX = '-module ',
    #FORTRANMODDIR = '${TARGET.dir}',
    LINK = '/opt/intel_fc_80/bin/ifort')

#
# Build dependency tree
#
allobjs = []
for sd in subdirs:
    buildDir = os.path.join('build',sd)
    consFile = os.path.join(buildDir,'SConscript')
    env.BuildDir(buildDir, sd)
    allobjs = allobjs + env.SConscript( consFile, exports = ['env','Glob']) 

#
# Remove any mod files. These should not be passed to the linker.
#
objs = filter(lambda o: str(o)[-4:] != '.mod', allobjs)

#
# Build program
#
env.Program('build/hello', ['hello.f90'] + objs )


